# 🧠 Navire – Technical Overview

This document provides a deep technical breakdown of Navire’s architecture, design principles, and implementation strategies.

---

## ⚙️ 1. Architecture Overview

At its core, Navire is composed of two main components:

1. **Core API (Brain)**  
   - Exposes a unified HTTP API (`/notify`)  
   - Handles authentication, validation, templating, and routing decisions  
   - Pushes validated events into the pub/sub pipeline

2. **Dispatch Worker (Muscle)**  
   - Subscribes to notification events from the pub/sub layer  
   - Loads templates and renders final messages  
   - Sends messages to configured notifiers with retry and backoff logic

### Pub/Sub Layer


Navire will be **pub/sub agnostic**, supporting multiple backends such as:

- Redis Streams
- NATS
- Kafka
- RabbitMQ

The pub/sub layer is pluggable and implementation-agnostic, enabling teams to choose the messaging system that best fits their infrastructure (e.g., Redis Streams in development, Kafka or NATS in production).
This decouples ingestion from delivery and allows horizontal scaling by simply adding more dispatch workers.

---

## 🔐 2. Security Model

The `/notify` endpoint is designed for **machine-to-machine communication**, not human interaction.  
Authentication uses **signed tokens** containing all necessary claims for stateless validation.

**Validation guarantees:**

* Signature verification (HMAC or RSA)
* Tenant isolation
* Optional template-level restrictions
* Scope-based authorization

This ensures secure, high-throughput validation without database lookups.

---

## 📨 3. Event Flow

1. **Client** sends a `POST /notify` request with a JSON payload.
2. **Core API** validates, authenticates, authorizes, and applies rate limiting.
3. **Core** pushes an `EventEnvelope` into the pub/sub system.
4. **Dispatch Worker** consumes the event and loads the appropriate template.
5. **Dispatch** renders the message and sends it to configured notifiers.
6. **Result** is logged, metrics updated, and failures retried with backoff.

---

## 🛠️ 4. Key Components

### Core API

* HTTP Server (Go `net/http`) with middleware for logging, tracing, and security headers
* JSON binding, validation, and sanitization layer
* Routing and template resolution engine
* Rate limiting (leaky bucket)
* Idempotency with Redis (`SETNX + TTL`)

### Dispatch Worker

* Event consumer loop (`XREADGROUP`, `SUBSCRIBE`, etc.)
* Template renderer with in-memory cache
* Concurrent sender with retry and backoff
* Dead Letter Queue for failed messages
* Metrics exporter (Prometheus)

### Notifiers (Adapters)

* Gotify
* ntfy
* Slack
* Discord
* Webhooks (generic HTTP POST)
* (Planned) Mattermost, PagerDuty, Teams, Rocket.Chat, Pushover, Apprise, Home Assistant, Matrix, etc.
* (Planned) Telegram (will be supported but not recommended for critical use cases, Navire will not be liable for data leaks or breaches resulting from its use)
* SMS and Email will never be handled. It's an architectural decision to keep Navire focused on real-time notifications.

---

## 🧰 5. Example `/notify` Request

```json
{
  "id": "uuid",     // generated by client or server (if not provided)
  "timestamp": "2025-09-22T15:30:00Z",
  "tenant": "acme",
  "priority": "high",            // low | normal | high | critical
  "idempotency_key": "abc123",
  "template": "XYZ123",
  "variant": "release_fail",   // which variant of the template to use
  "data": { // example of data for the template placeholders (not exhaustive or fixed)
    "service": "keg-cli",
    "version": "1.4.2",
    "url": "https://ci.example.com/logs/release/1.4.2"
  }
}
```

---

## 🧪 6. Project Roadmap

| Version | Focus Area                                               |
| ------: | ---------------------------------------------------------|
|   0.0.1 | MVP: Core API, /notify, dispatch worker, basic notifiers |
|   0.0.2 | Reliability: retry, DLQ, routing engine, security        |
|   0.0.3 | CE UI: HTMX Admin UI                                     |
|   0.0.5 | Enterprise UI: React SPA                                 |
|   0.0.7 | Enterprise Features: multi-tenancy, audit logging        |

---

## 🧱 7. Repository Structure

```
navire/
├─ cmd/               # Entrypoints (core, dispatch)
├─ core/              # Core API (brain)
├─ dispatch/          # Dispatch worker (muscle)
├─ shared/            # Shared libraries
├─ webui/             # CE (HTMX) + Enterprise (React) UIs
├─ deploy/            # Docker, Kubernetes, Helm
├─ e2e/               # End-to-end tests
├─ docs/              # Documentation
└─ scripts/           # Build/test utilities
```

---

## 📈 8. Design Principles

* 🧱 **Clean Architecture** – clear boundaries between domain, application, and adapters
* ⚙️ **SOLID Principles** – maintainable, testable, extensible code
* 🚀 **Cloud-native by design** - stateless services, environment-driven configuration, horizontally scalable
* 📊 **Observability-first** – metrics, logging, tracing built-in
* 🪶 **Minimal dependencies** – standard library first

---

## 🚫 Non-Goals

Navire is **not** designed to:
- Deliver notifications via SMS or Email  
- Replace full-featured incident management tools  
- Act as a stateful event store or long-term message broker
- Handle human interaction workflows (e.g., ticketing, approvals)

---

## 📌 Final Notes

Navire is designed to be the **control plane for modern notification infrastructure**.
It aims to remove complexity, unify delivery, and provide a scalable, developer-friendly interface for critical communication workflows.